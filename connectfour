#what are classes?

from c4minimax import *

import random
import os
import time

class Board(object):
    """Object that holds board values
    """

    def __init__(self, arg):
        super(, self).__init__()
        self.arg = arg

    def board():
        for i in range(1.8):
            print('+---+---+---+---+---+---+')
            print('|   |   |   |   |   |   |')
        print('+---+---+---+---+---+---+')
    board()

    def getNewBoard():
        board()

BOARDHEIGHT = 7
BOARDWIDTH  = 6
mainboard = getNewBoard()

class Game(object):

"""Code that holds Connect 4 game values"""

    board = None
    turn = None
    finished = None
    winner = None
    turn = None
    players = [None, None]
    game_name = u"Connect Four"
    markers = ["X", "O"]


 os.system( [ 'clear', 'cls' ][ os.name == 'nt' ] ) ##what does this mean?
        print(u"Welcome to {0}!".format(self.game_name))
        print("Should Player 1 be a Human or a Computer?")
        while self.players[0] == None:
            choice = str(input("Type 'H' or 'C': "))
            if choice == "Human" or choice.lower() == "h":
                name = str(input("What is Player 1's name? "))
                self.players[0] = Player(name, self.markers[0])
            elif choice == "Computer" or choice.lower() == "c":
                name = str(input("What is Player 1's name? "))
                print("Choose AI difficulty of either Easier or Harder")
                if diff == "Easier" or choice.lower() == "e":
                    diff = ###finish after AI difficulty finished
                elif choice == "Harder" or choice.lower() == "h":
                    diff = ###same
                else:
                    print("Invalid choice, please try again")
                self.players[0] = AIPlayer(name, self.markers[0], #difficulty)
            else:
                print("Invalid choice, please try again")
        print("{0} will be {1}".format(self.players[0].name, self.markers[0]))

        print("Should Player 2 be a Human or a Computer?")
        while self.players[1] == None:
            choice = str(input("Type 'H' or 'C': "))
            if choice == "Human" or choice.lower() == "h":
                name = str(input("What is Player 2's name? "))
                self.players[1] = Player(name, self.markers[1])
            elif choice == "Computer" or choice.lower() == "c":
                name = str(input("What is Player 2's name? "))
                print("Choose AI difficulty of either Easier or Harder")
                if diff == "Easier" or choice.lower() == "e":
                    diff = ###finish after AI difficulty finished
                elif choice == "Harder" or choice.lower() == "h":
                    diff = ###same
                else:
                    print("Invalid choice, please try again")
                self.players[1] = AIPlayer(name, self.colors[1], #difficulty)
            else:
                print("Invalid choice, please try again")
        print("{0} will be {1}".format(self.players[1].name, self.markers[1]))

def InputItem():
	item = ''
	print('Wecome to C4!')
	while not (item == 'X' or item == 'O') :
		item = input('Player 1, do you want to be X or O?')

	if item == 'X':
		return ['X', 'O']
        ### assign X to player1, etc
	if item == 'O':
		return ['O', 'X']

print(drawBoard(mainboard))

    self.turn = self.players[0]
    #have x go first (random decision)
    self.board = []
    for i in range(6):
        self.board.append([])
        for j in range(7):
            self.board[i].append('')


def playGame(self):
    """Start new game function
    """
    self.round = 1
    self.finished = False
    self.winner = None
    self.turn = self.players[0]
    self.board = []
    for i in range(6):
        self.board.append([])
        for j in range(7):
            self.board[i].append('')

def nextMove(self):
    player = self.turn
    if self.round > 42:
        self.finished = True
        return
        #stalemate
    move = player.move(self.board)

    for i in range(6):
        if self.board[i][move] == ''>
            self.board[i][move] = player.marker
            self.switch()
            self.check4inarow()
            self.printState()
            return

        #this means column is full
        print("Column is full, try again.")
        return

##write start new game function


#### AI is minimax

class AI(Player):
    ""AI object that uses AI algorithm, minimax. Difficulty parameter directs to 2 different algorithms"

    difficulty = None

    def __init__(self, name, marker, difficulty="e"):
        self.type = "AI"
        self.name = name
        self.marker = marker
        self.difficulty = difficulty

#### incomplete
def move(self, state):
        print("{0}'s turn.  {0} is {1}".format(self.name, self.marker))
        m = Minimax(state)
        best_move, value = m.bestMove(self.difficulty, state, self.marker)
        return best_move

class human(player):
    """class for human players
    """

    type = None #between 'AI' and 'human'
    name = None
    marker = None

    def __init__(self, name, color):
        self.type = "Human"
        self.name = name
        self.color = color

def check4inarow(self):
        for i in range(6):
            for j in range(7):
                if self.board[i][j] != '':
                    #check if vertical 4inarow starts at (i, j)
                    if self.checkVer(i,j):
                        self.finished = True
                        return

                    #check horizontal
                    if self.checkHor(i, j):
                        self.finished = True
                        return

                    #check diagonal
                    diag_4, slope = self.diagonalCheck(i, j)
                    if diag_4:
                        print(slope)
                        self.finished = True
                        return

    def checkVer(self, row, col):
        4inarow = False
        consecutiveCount = 0

        for i in range(row, 6):
            if self.board[i][col].lower() == self.board[row][col].lower():
                consecutiveCount += 1
            else:
                break
        if consecutiveCount >=4
            4inarow = True
            if self.players[0].marker.lower() == self.board[row][col].lower():
                self.winner = self.players[0]
            else:
                self.winner = self.players[1]
        return 4inarow

    def checkHor(self, row, col):
        4inarow = False
        consecutiveCount = 0

        for j in range(col, 7)
            if self.board[row][j].lower() == self.board[row][col].lower():
                consecutiveCount += 1
            else:
                break

        if consecutiveCount >= 4:
            4inarow = True
            if self.players[0].marker.lower() == self.board[row][col].lower():
                self.winner = self.players[0]
            else:
                self.winner = self.players[1]
        return 4inarow

    def checkDiag(self, row, col):
        4inarow = False
        count = 0
        slope = None

        #diagonals with + slope

        consecutiveCount = 0
        j = col
        for i in range(row, 6):
            if j>6:
                break
            elif self.board[i][j].lower() == self.board[row][col].lower():
                consecutiveCount += 1
            else:
                break
            j += 1

        if consecutiveCount >= 4:
            count += 1
            slope = 'pos'
            if self.players[0].marker.lower() == self.board[row][col].lower():
                self.winner = self.players[0]
            else:
                self.winner = self.players[1]

        #- slope

        consecutiveCount = 0
        j = col
        for i in range(row, -1, -1):
            if j > 6:
                break
            elif self.board[i][j].lower() == self.board[row][col].lower():
                consecutiveCount += 1
            else:
                break
            j += 1

        if consecutiveCount >= 4:
            count += 1
            slope = 'neg'
            if self.players[0].color.lower() == self.board[row][col].lower():
                self.winner = self.players[0]
            else:
                self.winner = self.players[1]

        if count > 0:
            4inarow = True
        if count == 2:
            slope = 'both'
        return 4inarow, slope
